package memshare

import (
	"bytes"
	"crypto/aes"
	"crypto/cipher"
	"crypto/rand"
	"crypto/sha256"
	"encoding/base64"
	"errors"
	"io"
	"os"
	"path/filepath"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"unsafe"
)


var pointerList map[string]any = map[string]any{}
var pListMu sync.Mutex = sync.Mutex{}

type nullBuilder[T any] struct {
	null T
}

type toInterface struct {
	val interface{}
}

type CryptKey struct {
	key []byte
}

// Stringify converts a vars pointer to a string and pushes it to persistant memory
func Stringify[T any](v *T, key ...interface{CryptKey|string|[]byte|any}) (string, error) {
	ps := "&" + encodeType(*v) + "*" + strconv.FormatUint(uint64(uintptr(unsafe.Pointer(v))), 36)

	pListMu.Lock()
	pointerList[ps] = v
	pListMu.Unlock()

	encKey := []byte{}
	if len(key) != 0 {
		switch reflect.TypeOf(key[0]).String() {
		case "*memshare.CryptKey":
			encKey = key[0].(*CryptKey).key
		case "string":
			encKey = []byte(key[0].(string))
		case "[]byte":
			encKey = key[0].([]byte)
		}
	}

	if len(encKey) != 0 {
		enc, err := encrypt([]byte(ps), encKey)
		if err != nil {
			return "", err
		}
		return "&"+encodeToString(enc), nil
	}

	randKey := RandBytes(16)
	enc, err := encrypt([]byte(ps), []byte(randKey))
	if err != nil {
		return "", err
	}
	return "&"+encodeToString(enc)+"#"+randKey, nil
}

// Parse converts a stringified pointer back to a pointer attached to a new var
//
// notice: this new var may be ignored by the garbage collector
func Parse[T any](ps string, key ...interface{CryptKey|string|[]byte|any}) *T {
	// ensure string is a valid pointer generated by this module
	if len(ps) < 4 || ps[0] != '&' {
		return nil
	}

	encKey := []byte{}
	if len(key) != 0 {
		switch reflect.TypeOf(key[0]).String() {
		case "*memshare.CryptKey":
			encKey = key[0].(*CryptKey).key
		case "string":
			encKey = []byte(key[0].(string))
		case "[]byte":
			encKey = key[0].([]byte)
		}
	}

	// get encryption data
	data := strings.SplitN(ps[1:], "#", 2)
	if len(data) == 0 || len(data[0]) == 0 || (len(encKey) == 0 && (len(data) != 2 || len(data[1]) == 0)) {
		return nil
	}
	b, err := decodeFromString(data[0])
	if err != nil {
		return nil
	}

	// decrypt pointer
	if len(data) == 2 && len(data[1]) != 0 {
		dec, err := decrypt(b, []byte(data[1]))
		if err != nil {
			return nil
		}
		ps = string(dec)
	}else if len(encKey) != 0 {
		dec, err := decrypt(b, encKey)
		if err != nil {
			return nil
		}
		ps = string(dec)
	}else{
		return nil
	}

	// ensure string is a valid pointer generated by this module
	if len(ps) < 4 || ps[0] != '&' {
		return nil
	}

	// get pointer data
	pd := strings.SplitN(ps[1:], "*", 2)
	if len(pd) != 2 || len(pd[0]) == 0 || len(pd[1]) == 0 {
		return nil
	}

	// verify type
	t := encodeType(nullBuilder[T]{}.null)
	if string(pd[0]) != t {
		return nil
	}

	// convert to pointer
	pint, err := strconv.ParseUint(pd[1], 36, 0)
	if err != nil {
		return nil
	}
	p := unsafe.Pointer(uintptr(pint))

	// convert to type and test if pointer is valid
	defer func() {
		recover()
	}()
	v := (*T)(p)
	_ = *v

	return v
}

// Delete removes a var from persistant memory, and allows it to be handled by the garbage collector
//
// notice: be careful when deleting a pointer from memory (parsed pointers might not allocate memory)
func Delete[T any](v *T){
	ps := "&" + encodeType(*v) + "*" + strconv.FormatUint(uint64(uintptr(unsafe.Pointer(v))), 36)

	pListMu.Lock()
	delete(pointerList, ps)
	pListMu.Unlock()
}

// KeyFile grabs a file, and loads up an encryption key to be used in the parse and stringify functions
//
// this method will return a struct, which contains the key as a private param
func KeyFile(path string) (*CryptKey, error) {
	var err error
	path, err = filepath.Abs(path)
	if err != nil {
		return &CryptKey{}, err
	}
	b, err := os.ReadFile(path)
	if err != nil {
		return &CryptKey{}, err
	}

	b = bytes.TrimSpace(b)
	if len(b) == 0 {
		return &CryptKey{}, errors.New("key file is blank")
	}

	return &CryptKey{b}, nil
}

func encodeType[T any](v T) string {
	t := base64.StdEncoding.EncodeToString([]byte(reflect.TypeOf(v).String()))
	if t[len(t)-2] == '=' {
		t = t[:len(t)-2] + "2"
	}else if t[len(t)-1] == '=' {
		t = t[:len(t)-1] + "1"
	}else{
		t += "0"
	}
	return t
}

// Encrypt runs AES-CFB Encryption
//
// the key is also hashed with SHA256
func encrypt(text []byte, key []byte) ([]byte, error) {
	keyHash := sha256.Sum256(key)

	block, err := aes.NewCipher(keyHash[:])
	if err != nil {
		return []byte{}, err
	}

	ciphertext := make([]byte, aes.BlockSize+len(text))
	iv := ciphertext[:aes.BlockSize]
	if _, err := io.ReadFull(rand.Reader, iv); err != nil {
		return []byte{}, err
	}

	stream := cipher.NewCFBEncrypter(block, iv)
	stream.XORKeyStream(ciphertext[aes.BlockSize:], text)

	return []byte(base64.StdEncoding.EncodeToString(ciphertext)), nil
}

// Decrypt runs AES-CFB Decryption
//
// the key is also hashed with SHA256
func decrypt(text []byte, key []byte) ([]byte, error) {
	keyHash := sha256.Sum256(key)

	ciphertext, err := base64.StdEncoding.DecodeString(string(text))
	if err != nil {
		return []byte{}, err
	}

	block, err := aes.NewCipher(keyHash[:])
	if err != nil {
		return []byte{}, err
	}

	if len(ciphertext) < aes.BlockSize {
		return []byte{}, errors.New("ciphertext too short")
	}
	iv := ciphertext[:aes.BlockSize]
	ciphertext = ciphertext[aes.BlockSize:]
	stream := cipher.NewCFBDecrypter(block, iv)

	stream.XORKeyStream(ciphertext, ciphertext)
	return ciphertext, nil
}

// RandBytes generates random bytes using crypto/rand
func RandBytes(size int) string {
	b := make([]byte, size)
	rand.Read(b)
	b = []byte(base64.URLEncoding.EncodeToString(b))

	for len(b) < size {
		a := make([]byte, size)
		rand.Read(a)
		a = []byte(base64.URLEncoding.EncodeToString(a))
		b = append(b, a...)
	}

	s := strings.TrimRight(base64.URLEncoding.EncodeToString(b), "=")
	for len(s) < size {
		s += "0"
	}
	return s[:size]
}

func encodeToString(b []byte) string {
	s := base64.StdEncoding.EncodeToString(b)
	if s[len(s)-2] == byte(base64.StdPadding) {
		s = s[:len(s)-2] + "2"
	}else if s[len(s)-1] == byte(base64.StdPadding) {
		s = s[:len(s)-1] + "1"
	}else{
		s += "0"
	}

	return s
}

func decodeFromString(s string) ([]byte, error) {
	if len(s) == 0 {
		return []byte{}, errors.New("string is empty")
	}
	switch s[len(s)-1] {
	case '0':
		s = s[:len(s)-1]
	case '1':
		s = s[:len(s)-1] + string(byte(base64.StdPadding))
	case '2':
		s = s[:len(s)-1] + string([]byte{byte(base64.StdPadding), byte(base64.StdPadding)})
	}

	b, err := base64.StdEncoding.DecodeString(s)
	if err != nil {
		return []byte{}, err
	}

	return b, nil
}
