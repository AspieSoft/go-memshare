package memshare

import (
	"encoding/base64"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"unsafe"
)

type nullBuilder[T any] struct {
	null T
}

func main(){
	var1 := "test"
	fmt.Println(var1)

	p := Stringify[string](&var1)
	fmt.Println(string(p))

	var2 := Parse[string](p)
	if var2 == nil {
		fmt.Println("error")
		return
	}
	fmt.Println(*var2)

	*var2 = "test2"
	fmt.Println(var1, *var2)
}

func Stringify[T any](v *T) string {
	p := uintptr(unsafe.Pointer(v))
	return "&" + encodeType(*v) + "*" + strconv.FormatUint(uint64(p), 36)
}

func Parse[T any](ps string) *T {
	// ensure string is a valid pointer generated by this module
	if len(ps) < 4 || ps[0] != '&' {
		return nil
	}

	// get pointer data
	pd := strings.SplitN(ps[1:], "*", 2)
	if len(pd) != 2 || len(pd[0]) == 0 || len(pd[1]) == 0 {
		return nil
	}

	// verify type
	t := encodeType(nullBuilder[T]{}.null)
	if string(pd[0]) != t {
		return nil
	}

	// convert to pointer
	pint, err := strconv.ParseUint(pd[1], 36, 0)
	if err != nil {
		return nil
	}
	p := unsafe.Pointer(uintptr(pint))

	// convert to type and test if pointer is valid
	defer func() {
		recover()
	}()
	v := (*T)(p)
	_ = *v

	return v
}

func encodeType[T any](v T) string {
	t := base64.StdEncoding.EncodeToString([]byte(reflect.TypeOf(v).String()))
	if t[len(t)-2] == '=' {
		t = t[:len(t)-2] + "2"
	}else if t[len(t)-1] == '=' {
		t = t[:len(t)-1] + "1"
	}else{
		t += "0"
	}
	return t
}
